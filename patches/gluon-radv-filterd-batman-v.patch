diff --git a/package/gluon-radv-filterd/src/gluon-radv-filterd.c b/package/gluon-radv-filterd/src/gluon-radv-filterd.c
index b1620cae..666622a9 100644
--- a/package/gluon-radv-filterd/src/gluon-radv-filterd.c
+++ b/package/gluon-radv-filterd/src/gluon-radv-filterd.c
@@ -59,23 +59,23 @@
 
 #include "mac.h"
 
-// Recheck TQs after this time even if no RA was received
+// Recheck throughputs after this time even if no RA was received
 #define MAX_INTERVAL 60
 
-// Recheck TQs at most this often, even if new RAs were received (they won't
-// become the preferred routers until the TQs have been rechecked)
+// Recheck throughputs at most this often, even if new RAs were received (they won't
+// become the preferred routers until the throughputs have been rechecked)
 // Also, the first update will take at least this long
 #define MIN_INTERVAL 15
 
-// Remember the originator of a router for at most this period of time (in
+// Remember the neighbor of a router for at most this period of time (in
 // seconds). Re-read it from the transtable afterwards.
-#define ORIGINATOR_CACHE_TTL 300
+#define neighbor_CACHE_TTL 300
 
 // max execution time of a single ebtables call in nanoseconds
 #define EBTABLES_TIMEOUT 500000000 // 500ms
 
-// TQ value assigned to local routers
-#define LOCAL_TQ 512
+// throughput value assigned to local routers
+#define LOCAL_throughput 512
 
 #define BUFSIZE 1500
 
@@ -107,8 +107,8 @@ struct router {
 	struct router *next;
 	struct ether_addr src;
 	struct timespec eol;
-	struct ether_addr originator;
-	uint16_t tq;
+	struct ether_addr neighbor;
+	uint16_t throughput;
 };
 
 static struct global {
@@ -116,7 +116,7 @@ static struct global {
 	struct router *routers;
 	const char *mesh_iface;
 	const char *chain;
-	uint16_t max_tq;
+	uint16_t max_throughput;
 	uint16_t hysteresis_thresh;
 	struct router *best_router;
 	volatile sig_atomic_t stop_daemon;
@@ -188,8 +188,8 @@ static void usage(const char *msg) {
 	fprintf(stderr,
 		"Usage: %s [-m <mesh_iface>] [-t <thresh>] -c <chain> -i <iface>\n\n"
 		"  -m <mesh_iface>  B.A.T.M.A.N. advanced mesh interface used to get metric\n"
-		"                   information (\"TQ\") for the available gateways. Default: bat0\n"
-		"  -t <thresh>      Minimum TQ difference required to switch the gateway.\n"
+		"                   information (\"throughput\") for the available gateways. Default: bat0\n"
+		"  -t <thresh>      Minimum throughput difference required to switch the gateway.\n"
 		"                   Default: 0\n"
 		"  -c <chain>       ebtables chain that should be managed by the daemon. The\n"
 		"                   chain already has to exist on program invocation and should\n"
@@ -289,8 +289,8 @@ static void parse_cmdline(int argc, char *argv[]) {
 				threshold = strtoul(optarg, &endptr, 10);
 				if (*endptr != '\0')
 					exit_errmsg("Threshold must be a number: %s", optarg);
-				if (threshold >= LOCAL_TQ)
-					exit_errmsg("Threshold too large: %ld (max is %d)", threshold, LOCAL_TQ);
+				if (threshold >= LOCAL_throughput)
+					exit_errmsg("Threshold too large: %ld (max is %d)", threshold, LOCAL_throughput);
 				G.hysteresis_thresh = (uint16_t) threshold;
 				break;
 			case 'h':
@@ -318,7 +318,7 @@ static struct router *router_find_orig(const struct ether_addr *orig) {
 	struct router *router;
 
 	foreach(router, G.routers) {
-		if (ether_addr_equal(router->originator, *orig))
+		if (ether_addr_equal(router->neighbor, *orig))
 			return router;
 	}
 
@@ -337,7 +337,7 @@ static struct router *router_add(const struct ether_addr *mac) {
 	G.routers = router;
 	router->eol.tv_sec = 0;
 	router->eol.tv_nsec = 0;
-	memset(&router->originator, 0, sizeof(router->originator));
+	memset(&router->neighbor, 0, sizeof(router->neighbor));
 
 	return router;
 }
@@ -408,7 +408,7 @@ static int parse_tt_global(struct nl_msg *msg,
 {
 	static const enum batadv_nl_attrs mandatory[] = {
 		BATADV_ATTR_TT_ADDRESS,
-		BATADV_ATTR_ORIG_ADDRESS,
+		BATADV_ATTR_NEIGH_ADDRESS,
 	};
 	struct nlattr *attrs[BATADV_ATTR_MAX + 1];
 	struct nlmsghdr *nlh = nlmsg_hdr(msg);
@@ -436,7 +436,7 @@ static int parse_tt_global(struct nl_msg *msg,
 		return NL_OK;
 
 	addr = nla_data(attrs[BATADV_ATTR_TT_ADDRESS]);
-	orig = nla_data(attrs[BATADV_ATTR_ORIG_ADDRESS]);
+	orig = nla_data(attrs[BATADV_ATTR_NEIGH_ADDRESS]);
 
 	if (!attrs[BATADV_ATTR_FLAG_BEST])
 		return NL_OK;
@@ -449,28 +449,28 @@ static int parse_tt_global(struct nl_msg *msg,
 	if (!router)
 		return NL_OK;
 
-	DEBUG_MSG("Found originator for " F_MAC ", it's " F_MAC,
+	DEBUG_MSG("Found neighbor for " F_MAC ", it's " F_MAC,
 		  F_MAC_VAR(router->src), F_MAC_VAR(mac_b));
-	router->originator = mac_b;
+	router->neighbor = mac_b;
 
 	return NL_OK;
 }
 
-static int parse_originator(struct nl_msg *msg,
+static int parse_neighbor(struct nl_msg *msg,
 			    void *arg __attribute__((unused)))
 {
 
 	static const enum batadv_nl_attrs mandatory[] = {
-		BATADV_ATTR_ORIG_ADDRESS,
-		BATADV_ATTR_TQ,
+		BATADV_ATTR_NEIGH_ADDRESS,
+		BATADV_ATTR_THROUGHPUT,
 	};
 	struct nlattr *attrs[BATADV_ATTR_MAX + 1];
 	struct nlmsghdr *nlh = nlmsg_hdr(msg);
 	struct ether_addr mac_a;
 	struct genlmsghdr *ghdr;
 	struct router *router;
-	uint8_t *orig;
-	uint8_t tq;
+	uint8_t *neigh;
+	uint32_t throughput;
 
 	// parse netlink entry
 	if (!genlmsg_valid_hdr(nlh, 0))
@@ -478,7 +478,7 @@ static int parse_originator(struct nl_msg *msg,
 
 	ghdr = nlmsg_data(nlh);
 
-	if (ghdr->cmd != BATADV_CMD_GET_ORIGINATORS)
+	if (ghdr->cmd != BATADV_CMD_GET_NEIGHBORS)
 		return NL_OK;
 
 	if (nla_parse(attrs, BATADV_ATTR_MAX, genlmsg_attrdata(ghdr, 0),
@@ -489,8 +489,8 @@ static int parse_originator(struct nl_msg *msg,
 	if (batadv_genl_missing_attrs(attrs, mandatory, ARRAY_SIZE(mandatory)))
 		return NL_OK;
 
-	orig = nla_data(attrs[BATADV_ATTR_ORIG_ADDRESS]);
-	tq = nla_get_u8(attrs[BATADV_ATTR_TQ]);
+	neigh = nla_data(attrs[BATADV_ATTR_NEIGH_ADDRESS]);
+	throughput = nla_get_u8(attrs[BATADV_ATTR_THROUGHPUT]);
 
 	if (!attrs[BATADV_ATTR_FLAG_BEST])
 		return NL_OK;
@@ -502,11 +502,11 @@ static int parse_originator(struct nl_msg *msg,
 	if (!router)
 		return NL_OK;
 
-	DEBUG_MSG("Found TQ for router " F_MAC " (originator " F_MAC "), it's %d",
-		  F_MAC_VAR(router->src), F_MAC_VAR(router->originator), tq);
-	router->tq = tq;
-	if (router->tq > G.max_tq)
-		G.max_tq = router->tq;
+	DEBUG_MSG("Found throughput for router " F_MAC " (neighbor " F_MAC "), it's %d",
+		  F_MAC_VAR(router->src), F_MAC_VAR(router->neighbor), throughput);
+	router->throughput = throughput;
+	if (router->throughput > G.max_throughput)
+		G.max_throughput = router->throughput;
 
 	return NL_OK;
 }
@@ -549,31 +549,31 @@ static int parse_tt_local(struct nl_msg *msg,
 	if (!router)
 		return NL_OK;
 
-	DEBUG_MSG("Found router " F_MAC " in transtable_local, assigning TQ %d",
-		  F_MAC_VAR(router->src), LOCAL_TQ);
-	router->tq = LOCAL_TQ;
-	if (router->tq > G.max_tq)
-		G.max_tq = router->tq;
+	DEBUG_MSG("Found router " F_MAC " in transtable_local, assigning throughput %d",
+		  F_MAC_VAR(router->src), LOCAL_throughput);
+	router->throughput = LOCAL_throughput;
+	if (router->throughput > G.max_throughput)
+		G.max_throughput = router->throughput;
 
 	return NL_OK;
 }
 
-static void update_tqs(void) {
+static void update_throughputs(void) {
 	static const struct ether_addr unspec = {};
 	struct router *router;
-	bool update_originators = false;
+	bool update_neighbors = false;
 	struct batadv_nlquery_opts opts;
 	int ret;
 
-	// reset TQs
+	// reset throughputs
 	foreach(router, G.routers) {
-		router->tq = 0;
-		if (ether_addr_equal(router->originator, unspec))
-			update_originators = true;
+		router->throughput = 0;
+		if (ether_addr_equal(router->neighbor, unspec))
+			update_neighbors = true;
 	}
 
-	// translate all router's MAC addresses to originators simultaneously
-	if (update_originators) {
+	// translate all router's MAC addresses to neighbors simultaneously
+	if (update_neighbors) {
 		opts.err = 0;
 		ret = batadv_genl_query(G.mesh_iface,
 					BATADV_CMD_GET_TRANSTABLE_GLOBAL,
@@ -582,18 +582,18 @@ static void update_tqs(void) {
 			fprintf(stderr, "Parsing of global translation table failed\n");
 	}
 
-	// look up TQs of originators
-	G.max_tq = 0;
+	// look up throughputs of neighbors
+	G.max_throughput = 0;
 	opts.err = 0;
 	ret = batadv_genl_query(G.mesh_iface,
-				BATADV_CMD_GET_ORIGINATORS,
-				parse_originator, NLM_F_DUMP, &opts);
+				BATADV_CMD_GET_NEIGHBORS,
+				parse_neighbor, NLM_F_DUMP, &opts);
 	if (ret < 0)
-		fprintf(stderr, "Parsing of originators failed\n");
+		fprintf(stderr, "Parsing of neighbors failed\n");
 
-	// if all routers have a TQ value, we don't need to check translocal
+	// if all routers have a throughput value, we don't need to check translocal
 	foreach(router, G.routers) {
-		if (router->tq == 0)
+		if (router->throughput == 0)
 			break;
 	}
 	if (router != NULL) {
@@ -606,15 +606,15 @@ static void update_tqs(void) {
 	}
 
 	foreach(router, G.routers) {
-		if (router->tq == 0) {
-			if (ether_addr_equal(router->originator, unspec))
+		if (router->throughput == 0) {
+			if (ether_addr_equal(router->neighbor, unspec))
 				DEBUG_MSG(
 					"Unable to find router " F_MAC " in transtable_{global,local}",
 					F_MAC_VAR(router->src));
 			else
 				DEBUG_MSG(
-					"Unable to find TQ for originator " F_MAC " (router " F_MAC ")",
-					F_MAC_VAR(router->originator),
+					"Unable to find throughput for neighbor " F_MAC " (router " F_MAC ")",
+					F_MAC_VAR(router->neighbor),
 					F_MAC_VAR(router->src));
 		}
 	}
@@ -679,11 +679,11 @@ static bool election_required(void)
 	if (!G.best_router)
 		return true;
 
-	/* should never happen. G.max_tq also contains G.best_router->tq */
-	if (G.max_tq < G.best_router->tq)
+	/* should never happen. G.max_throughput also contains G.best_router->throughput */
+	if (G.max_throughput < G.best_router->throughput)
 		return false;
 
-	if ((G.max_tq - G.best_router->tq) <= G.hysteresis_thresh)
+	if ((G.max_throughput - G.best_router->throughput) <= G.hysteresis_thresh)
 		return false;
 
 	return true;
@@ -697,29 +697,29 @@ static void update_ebtables(void) {
 	struct router *router;
 
 	if (!election_required()) {
-		DEBUG_MSG(F_MAC " is still good enough with TQ=%d (max_tq=%d), not executing ebtables",
+		DEBUG_MSG(F_MAC " is still good enough with throughput=%d (max_throughput=%d), not executing ebtables",
 			F_MAC_VAR(G.best_router->src),
-			G.best_router->tq,
-			G.max_tq);
+			G.best_router->throughput,
+			G.max_throughput);
 		return;
 	}
 
 	foreach(router, G.routers) {
-		if (router->tq == G.max_tq) {
+		if (router->throughput == G.max_throughput) {
 			snprintf(mac, sizeof(mac), F_MAC, F_MAC_VAR(router->src));
 			break;
 		}
 	}
 	if (G.best_router)
-		fprintf(stderr, "Switching from " F_MAC " (TQ=%d) to %s (TQ=%d)\n",
+		fprintf(stderr, "Switching from " F_MAC " (throughput=%d) to %s (throughput=%d)\n",
 			F_MAC_VAR(G.best_router->src),
-			G.best_router->tq,
+			G.best_router->throughput,
 			mac,
-			G.max_tq);
+			G.max_throughput);
 	else
-		fprintf(stderr, "Switching to %s (TQ=%d)\n",
+		fprintf(stderr, "Switching to %s (throughput=%d)\n",
 			mac,
-			G.max_tq);
+			G.max_throughput);
 	G.best_router = router;
 
 	if (fork_execvp_timeout(&timeout, "ebtables-tiny", (const char *[])
@@ -730,11 +730,11 @@ static void update_ebtables(void) {
 		error_message(0, 0, "warning: adding new rule to ebtables chain %s failed", G.chain);
 }
 
-static void invalidate_originators(void)
+static void invalidate_neighbors(void)
 {
 	struct router *router;
 	foreach(router, G.routers) {
-		memset(&router->originator, 0, sizeof(router->originator));
+		memset(&router->neighbor, 0, sizeof(router->neighbor));
 	}
 }
 
@@ -798,13 +798,13 @@ int main(int argc, char *argv[]) {
 			// all routers could have expired, check again
 			if (G.routers != NULL) {
 				if(timespec_diff(&now, &next_invalidation, &diff)) {
-					invalidate_originators();
+					invalidate_neighbors();
 
 					next_invalidation = now;
-					next_invalidation.tv_sec += ORIGINATOR_CACHE_TTL;
+					next_invalidation.tv_sec += neighbor_CACHE_TTL;
 				}
 
-				update_tqs();
+				update_throughputs();
 				update_ebtables();
 
 				next_update = now;
